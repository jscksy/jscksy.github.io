<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="XinLai">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">6</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-21 10:07:06 / Modified: 10:07:29" itemprop="dateCreated datePublished" datetime="2021-04-21T10:07:06+08:00">2021-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h1><p>概述:在RandLA-Net网络的文献中看到使用了这一结构，故在上网查找了相关的资料学习，并将相应笔记记录于下。</p>
<h2 id="什么是残差（residual）？"><a href="#什么是残差（residual）？" class="headerlink" title="什么是残差（residual）？"></a>什么是残差（residual）？</h2><pre><code>&quot;残差在数理统计中是指实际观察值于估计值（拟合值）之间的差。&quot;
&quot;如果回归模型正确的话，我们可以将残差看作误差的观测值&quot;
</code></pre>
<p>举例来说，假如我们想找一个$x$，使得$f(x)=b$，给定一个$x$的估计值$x_0$，残差就是$b-f(x_0)$，误差就是$x-x_0$。</p>
<p>即使$x$不知道，我们依然可以计算残差，只是不能计算误差罢了。</p>
<h2 id="什么是残差神经网络（Residual-Networks，ResNets）？"><a href="#什么是残差神经网络（Residual-Networks，ResNets）？" class="headerlink" title="什么是残差神经网络（Residual Networks，ResNets）？"></a>什么是残差神经网络（Residual Networks，ResNets）？</h2><p>在了解残差网络之前，先了解下面这个问题。</p>
<p>　　Q1：神经网络越深越好吗？（Deeper is better？）</p>
<p>　　A1：如图 1 所示，在训练集上，传统神经网络越深效果不一定越好。而 Deep Residual Learning for Image Recognition 这篇论文认为，理论上，可以训练一个 shallower 网络，然后在这个训练好的 shallower 网络上堆几层 identity mapping（恒等映射） 的层，即输出等于输入的层，构建出一个 deeper 网络。这两个网络（shallower 和 deeper）得到的结果应该是一模一样的，因为堆上去的层都是 identity mapping。这样可以得出一个结论：理论上，在训练集上，Deeper 不应该比 shallower 差，即越深的网络不会比浅层的网络效果差。但为什么会出现图 1 这样的情况呢，随着层数的增多，训练集上的效果变差？这被称为退化问题（degradation problem），原因是随着网络越来越深，训练变得原来越难，网络的优化变得越来越难。理论上，越深的网络，效果应该更好；但实际上，由于训练难度，过深的网络会产生退化问题，效果反而不如相对较浅的网络。而残差网络就可以解决这个问题的，残差网络越深，训练集上的效果会越好。（测试集上的效果可能涉及过拟合问题。过拟合问题指的是测试集上的效果和训练集上的效果之间有差距。）</p>
<p><img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E4%B8%8D%E5%90%8C%E6%B7%B1%E5%BA%A6%E4%BC%A0%E7%BB%9F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94%E5%9B%BE.png"></p>
<p>（“plain” network指的是没有使用 shortcut connection 的网络）</p>
<p>残差网络通过加入 shortcut connections，变得更加容易被优化。包含一个 shortcut connection 的几层网络被称为一个残差块（residual block），如图 2 所示。（shortcut connection，即图 2 右侧从 $x$ 到 ⨁ 的箭头）</p>
<p><img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E6%AE%8B%E5%B7%AE%E5%9D%97.png"></p>
<p> …..</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/RandLA-Net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/RandLA-Net/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-21 09:59:30 / Modified: 10:05:43" itemprop="dateCreated datePublished" datetime="2021-04-21T09:59:30+08:00">2021-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RandLA-Net-大场景三维点云语义分割框架"><a href="#RandLA-Net-大场景三维点云语义分割框架" class="headerlink" title="RandLA-Net:大场景三维点云语义分割框架"></a>RandLA-Net:大场景三维点云语义分割框架</h1><p>概述：一种适用于大规模3D点云语义分割高效且轻量的模型。采用简单的随机点采样方法，随机采样导致的关键特征丢失，通过引入一种新颖的局部特征聚合模块来克服。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>3D点云语义分割的一个关键挑战是，深度传感器获取的原始点云通常是不规则采样，无结构且无序的，这种非结构化的数据，无法直接投入到深度卷积网络中进行训练。</p>
</li>
<li><p>PointNet的开拓性工作，使得直接处理3D点云成为可能。它使用共享的多层感知机MLP，但这无法获取每个点更为广泛的上下文信息。</p>
</li>
<li><p>为了学习更丰富的局部结构，后续又引入了许多专用的神经模块。这些模块可以归类为：<br>  <strong>1.neighbouring feature pooling</strong><br>  <strong>2.graph message passing</strong><br>  <strong>3.kernel-based convolution</strong><br>  <strong>4.attention-based aggregation</strong> </p>
</li>
<li><p>该模型相比于传统的3D点云语义分割方法，最大的优点在于对大规模数据场合的适用性。  </p>
<p>  <strong>限制因素</strong>：<br>  1.传统网络的点采样方法在计算上或内存效率低下<br>  2.大多数现有的本地特征学习算法，依靠计算昂贵的内核化或图形构造<br>  3.接受场大小有限，现有局部特征学习器要么无法捕获复杂结构，要么效率低下</p>
<p>  <strong>针对上述限制因素，本文创新性提出了</strong><br>  1.高效的采样方法（随机采样）<br>  （点采样和逆密度采样是小规模点云最常见的采样方法）<br>  2.有效的局部特征学习器 </p>
</li>
<li><p>$\color{red}{对每个3D点,首先引入局部空间编码（LocSE）单元以显示的保留局部和结构}$</p>
</li>
<li><p>$\color{red}{其次，利用attentive pooling来自动保留有用的本地功能}$</p>
</li>
<li><p>$\color{red}{第三，将多个LocSE单元和attentive pooling堆叠为膨胀的残差块，从而大大增加了每个点的有效接收场。}$</p>
</li>
<li><p>$\color{red}{所有这些神经组件都实现为共享MLP，因此具有显着的内存和计算效率}$</p>
</li>
</ul>
<h2 id="近期的其他相关研究"><a href="#近期的其他相关研究" class="headerlink" title="近期的其他相关研究"></a>近期的其他相关研究</h2><p>为了从3D点云中提取特征，传统方法通常是手动 hand-craft 特征。最近的基于学习的方法主要包括此处概述的基于投影的，基于体素的和基于点的方案。</p>
<ul>
<li><p><strong>基于投影和体素的网络：</strong>   为了利用2D CNNs的成功，许多工作将3D点云投影/展平到2D图像上，以解决对象检测的任务。但是，在投影过程中会丢失许多几何细节。或者，可以将点云体素化为3D网格，然后应用强大的3D CNNs。尽管它们在语义分割和对象检测方面取得了领先的成果，但它们的主要局限性是计算量大，特别是在处理大规模点云时。</p>
</li>
<li><p><strong>基于点的网络：</strong> 受PointNet / PointNet ++ 的启发，许多最新著作引入了复杂的神经模块来学习每点的局部特征。这些模块通常可分类为1）neighbouring feature pooling，2）graph message passing，3）kernel-based convolution 和 4） attention-based aggregation。尽管这些网络在小点云上已显示出令人鼓舞的结果，但是由于它们的高计算和内存成本，它们中的大多数不能直接扩展到大型方案。</p>
</li>
<li><p><strong>学习大规模点云：</strong> SPG 将大点云作为超级图进行预处理，以学习每个超点语义。最近的FCPN 和PCT 将基于体素的网络和基于点的网络都应用于处理大量的点云。但是，图分区和体素化在计算上都是昂贵的。相反，我们高效的RandLA-Net可进行端到端的训练，而无需任何其他的前/后处理步骤。</p>
</li>
</ul>
<p>与它们相比，RandLA-Net在四种方面有所区别：</p>
<ol>
<li>它仅依赖于网络内的随机采样，因此需要更少的内存和计算量；</li>
<li>所提出的局部特征聚合器可以通过明确考虑局部空间关系和点特征来获得连续更大的接收场，从而对于学习复杂的局部模式更加有效和健壮；</li>
<li>整个网络仅由共享的MLP组成，而不依赖于任何昂贵的操作（如图形构建和内核化），因此对于大规模点云而言，效率极高。</li>
<li>RandLA-Net可进行端到端的培训，而无需任何其他的前/后处理步骤</li>
</ol>
<h2 id="RandLA-Net"><a href="#RandLA-Net" class="headerlink" title="RandLA-Net"></a>RandLA-Net</h2><ul>
<li><p><strong>随机采样</strong></p>
</li>
<li><p><strong>本地特征聚合</strong></p>
<p>  如下图所示，局部特征聚合模块并行地应用于每个3D点，它由三个神经单元组成：1）局部空间编码（LocSE），2）attentive pooling 3 ）dilated residual block(扩张的残差块)。</p>
<p>  <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<ol>
<li><p>Local Spatial Encoding<br> 给定点云P以及每个点的特征（例如原始RGB或中间学习的特征），此局部空间编码单元会明确嵌入所有相邻点的x-y-z坐标，从而使相应的点特征始终知道其相对位置空间位置。这使LocSE单元可以显式观察局部几何图案，从而最终使整个网络受益，而有效地学习复杂的局部结构。特别地，该单元包括以下步骤：   </p>
<p> <strong>Finding Neighbouring Points.</strong> 对于第i个点，通过简单的基于逐点欧几里得距离的K近邻（KNN）算法收集其相邻点。  </p>
<p> <strong>Relative Point Position Encoding.</strong> 对于中心点$p_i$的每个最近的K个点{$p_i^1···p_i^k···p_i^K$},我们明确编码相对点位置，如下所示：</p>
<p> <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E5%B1%80%E9%83%A8%E7%BC%96%E7%A0%81%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li>$p_i$和$p_i^k$是点的x-y-z位置</li>
<li>⊕是串联操作</li>
<li>|| ·||计算相邻点和中心点之间的欧几里得距离</li>
<li>看起来$r_i^k$是根据冗余点位置信息进行编码的。有趣的是，这倾向于帮助网络学习局部特征并在实践中获得良好的性能。</li>
</ul>
<p> <strong>Point Feature Augmentation.</strong> 对于每个相邻点$p_i^k$，将编码的相对点位置$r_i^k$与它的对应点特征$f_i^k$串联在一起，从而获得增强的特征向量$\hat{f}_i^k$<br> 最终，LocSE单元的输出是一组新的相邻要素$\hat{F_i}={\hat{f}_i^1···\hat{f}_i^k···\hat{f}_i^K}$，它明确地编码了中心点$p_i$的局部几何结构。  </p>
</li>
<li><p>Attentive Pooling<br> 该神经单元用于汇总邻近点特征$\hat{F_i}$的集合。现有论文通常使用最大/平均池来硬集成相邻特征，从而导致大部分信息丢失。相比之下，网络转向强大的注意力机制来自动学习重要的本地特征。<br> <strong>Computing Attention Scores.</strong> 给定一组局部特征$\hat{F_i}$，设计了一个共享函数g()来为每个功能学习唯一的注意力得分。基本上，函数g()包含一个共享MLP，后跟softmax。它的正式定义如下：<br> <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%BE%97%E5%88%86.png"><br> 其中W是共享MLP的可学习权重.  </p>
<p> <strong>Weighted Summation.</strong> 学到的注意力分数可以看作是自动选择重要特征的softmask。正式地，这些特征的加权总和如下：<br> <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/K%E8%BF%91%E9%82%BB%E7%82%B9%E7%89%B9%E5%BE%81%E5%8A%A0%E6%9D%83.png"></p>
</li>
<li><p>Dilated Residual Block(膨胀残留块)</p>
<ul>
<li>由于将要对大的点云进行实质性的下采样，因此希望显着增加每个点的接收场，从而即使某些点被丢弃，输入点云的几何细节也更有可能被保留。</li>
<li>如图3所示，将多个LocSE和Attentive Pooling单元通过a skip connection堆叠在一起，作为扩张的残差块</li>
<li>为了进一步说明扩张残差块的功能，图4显示了红色3D点在第一次LocSE / Attentive Pooling操作之后观察到K KK个相邻点，然后在第二次之后能够从最多$K^2$个相邻点（即two-hop neighbourhood ）接收信息。这是扩大接受域并通过特征传播扩大有效邻域的cheap方法。</li>
<li>从理论上讲，堆叠的单位越多，此block的作用范围就越大，越强大。但是，更多的单元将不可避免地牺牲整体计算效率。另外，整个网络很可能会过度配合。</li>
<li>在RandLA-Net中，简单地堆叠了两组LocSE和Attentive Pooling作为标准残差块，在效率和效果之间取得了令人满意的平衡。   </li>
</ul>
<p> <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/%E6%AE%8B%E5%B7%AE%E5%9D%97%E6%89%A9%E5%A4%A7%E7%82%B9%E7%9A%84%E6%8E%A5%E5%8F%97%E5%9C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p> <strong>总体而言</strong></p>
<ul>
<li>局部特征聚合模块旨在通过明确考虑相邻的几何形状并显着增加接收场来有效保留复杂的局部结构。</li>
<li>该模块仅由前馈MLP组成，因此计算效率高。</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>通过堆叠多个局部特征聚合模块和随机采样层来实现RandLA-Net。</li>
<li>将Adam优化器与默认参数一起使用。初始学习率设置为0.01，并在每个时期后降低5％。最近点的数量K设置为16。</li>
<li>为了并行训练RandLA-Net，从每个点云中采样固定数量的点$(~10^6)$作为输入。</li>
<li>在测试过程中，整个原始点云将送到网络中，以推断每个点的语义，而无需任何预处理/后处理。  </li>
</ul>
</li>
</ol>
<p>  <strong>网络详细结构如下图所示：</strong><br>  <img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/RandLA-Net/RandLA-Net%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>图7显示了RandLANet的详细架构。</p>
</li>
<li><p>该网络遵循具有跳跃连接的广泛使用的编码器-解码器体系结构。</p>
</li>
<li><p>首先将输入点云馈送到共享的MLP层以提取每个点的特征。</p>
</li>
<li><p>然后使用四个编码和解码层来学习每个点的特征。</p>
</li>
<li><p>最后，使用三个完全连接的层和一个dropout层来预测每个点的语义标签。每个部分的详细信息如下：<br>  <strong>NetNetwork Input:</strong>  输入是一个大型的点云，大小为$N*d_{in}$（不考虑批处理）,其中N是点数$d_{in}$是每个输入点的特征维。</p>
<ul>
<li>对于S3DIS 和Semantic3D 数据集，每个点都由其3D坐标和颜色信息（即x-y-z-R-G-B）表示，</li>
<li>而SemanticKITTI [3]数据集的每个点仅由3D坐标表示。</li>
</ul>
<p>  <strong>Encoding Layers:</strong> </p>
<ul>
<li>网络中使用了四个编码层，以逐渐减小点云的大小并增加每点特征的尺寸。</li>
<li>每个编码层都包含一个局部特征聚合模块（第4.3节）和一个随机采样操作（第4.2节）。</li>
<li>点云以四倍的抽取比率进行下采样。特别是，每层之后仅保留25％的点，即（N→N/4→N/6→N/64→N /256）。</li>
<li>同时，逐点特征维逐渐增加每一层以保留更多信息，即（8→32→128→256→512）。</li>
</ul>
<p>  <strong>Decoding Layers:</strong></p>
<ul>
<li>在上述编码层之后使用四个解码层。</li>
<li>对于解码器中的每一层，我们首先使用KNN算法为每个查询点找到一个最近的相邻点，</li>
<li>然后通过$\color{red}最近邻插值$对点特征集进行上采样。</li>
<li>接下来，将经过上采样的特征图与通过skip连接对图层进行编码而生成的中间特征图进行级联，之后将共享的MLP应用于级联特征图。</li>
</ul>
<p>  <strong>Final Semantic Prediction:</strong></p>
<ul>
<li>每个点的最终语义标签是通过三个共享的全连接层（N，64）→（N，32）→（N，nclass）和a dropout layer获得的。dropout ratio 为0.5。</li>
</ul>
<p>  <strong>Network Output:</strong></p>
<ul>
<li>RandLA-Net的输出是所有点的预测语义，大小为$N*n_{class}$,其中$n_{class}$是类的数量。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-21 09:57:14 / Modified: 09:58:31" itemprop="dateCreated datePublished" datetime="2021-04-21T09:57:14+08:00">2021-04-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="隐马尔科夫模型"><a href="#隐马尔科夫模型" class="headerlink" title="隐马尔科夫模型"></a>隐马尔科夫模型</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>定义：</strong> 隐马尔科夫模型是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。</p>
<p>马尔科夫模型的形式定义如下：<br>设$Q$是所有可能的状态的集合，$V$是所有可能的观测的集合<br>$$Q={q_1,q_2,···,q_N},V={v_1,v_2,···,v_M}$$</p>
<p>其中，N是可能的状态数，M是可能的观测数.<br>I是长度为T的状态序列，O是对应的观测序列.<br>$$I={i_1,i_2,···,i_T}, O={o_1,o_2,···,o_r}$$</p>
<p><strong>齐次马尔科夫性假设：</strong> 即假设隐藏的马尔科夫链在任意时刻t的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻t无关</p>
<p><strong>观测独立性假设：</strong> 即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测及状态无关</p>
<p><img src="https://gitee.com/FenNuDeShaGua/pic-go-picturs/raw/master/image/%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/20/Cesium-Radar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/Cesium-Radar/" class="post-title-link" itemprop="url">Cesium_Radar</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-20 14:19:39 / Modified: 14:40:29" itemprop="dateCreated datePublished" datetime="2021-04-20T14:19:39+08:00">2021-04-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Cesium雷达模块"><a href="#Cesium雷达模块" class="headerlink" title="Cesium雷达模块"></a>Cesium雷达模块</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本模块的雷达效果是基于Cesium提供的接口实现的，没有涉及到底层WebGL代码的调整。该模块是在TypeScript和Cesium1.74的基础上实现的。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>在具体实现时，可以拆分成两个部分：雷达体与扫描体。<br><em><strong>雷达体的实现利用的是Cesium提供的Entity中的ellipsoid组件，该部分具体实现的核心代码如下所示：</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成雷达扫描体，主要利用Cesium的ellipsoid接口实现</span><br><span class="line">&#x2F;&#x2F; 基本上所有属性的接口都暴露出来了，可以动态的调整</span><br><span class="line">&#x2F;&#x2F; 雷达扫描体的形状主要由minimumClock、maximumClock、minimumCone、maximumCone四个属性控制</span><br><span class="line">let positions &#x3D; entity?.position;</span><br><span class="line">this.blueEllipse &#x3D; new Entity(&#123;</span><br><span class="line">    id: &quot;round_body&quot; + this._radasid,</span><br><span class="line">    position: positions !&#x3D;&#x3D; undefined ? positions : this._position,</span><br><span class="line">    orientation: new CallbackProperty(function (time) &#123;</span><br><span class="line">        let pos &#x3D; positions !&#x3D;&#x3D; undefined ? positions.getValue(time) : _this._position;</span><br><span class="line">        return Transforms.headingPitchRollQuaternion(</span><br><span class="line">            pos,</span><br><span class="line">            new HeadingPitchRoll(_this.hpr.heading * _Math.PI &#x2F; 180.0, _this.hpr.pitch * _Math.PI &#x2F; 180.0, _this.hpr.roll * _Math.PI &#x2F; 180.0)</span><br><span class="line">        );</span><br><span class="line">    &#125;, false),</span><br><span class="line">    ellipsoid: &#123;</span><br><span class="line">        show: new CallbackProperty(function () &#123; return _this._show; &#125;, false),</span><br><span class="line">        radii: new CallbackProperty(function () &#123; return new Cartesian3(_this._size, _this._size, _this._size); &#125;, false),</span><br><span class="line">        minimumClock: new CallbackProperty(function () &#123; return _Math.toRadians(_this._scanrange[0]); &#125;, false),</span><br><span class="line">        maximumClock: new CallbackProperty(function () &#123; return _Math.toRadians(_this._scanrange[1]); &#125;, false),</span><br><span class="line">        minimumCone: new CallbackProperty(function () &#123; return _Math.toRadians(_this._scanrange[2]); &#125;, false),</span><br><span class="line">        maximumCone: new CallbackProperty(function () &#123; return _Math.toRadians(_this._scanrange[3]); &#125;, false),</span><br><span class="line">        innerRadii: new Cartesian3(0.1, 0.1, 0.1),</span><br><span class="line">        material: new ColorMaterialProperty(new CallbackProperty(function () &#123;</span><br><span class="line">            return Color.fromCssColorString(_this._facecolor);</span><br><span class="line">        &#125;, false)),</span><br><span class="line">        outline: true,</span><br><span class="line">        outlineColor: new CallbackProperty(function () &#123;</span><br><span class="line">            return Color.fromCssColorString(_this._slicecolor);</span><br><span class="line">        &#125;, false),</span><br><span class="line">        outlineWidth: 1,</span><br><span class="line">        slicePartitions: new CallbackProperty(function () &#123; return _this._slice; &#125;, false)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 向组件集合中添加雷达体</span><br><span class="line">this.sensorEntities.set(&quot;round_body&quot; + this._radasid, this.blueEllipse);</span><br></pre></td></tr></table></figure>
<p>下面对雷达体各属性作简单的说明：<br>id：雷达体的id，由构造函数输入确定。<br>positions：雷达体的中心位置，优先由绑定物体位置序列确定，否则为输入的固定坐标。<br>orientation：雷达体的转向，由输入的hpr参数确定。<br>ellipsoid(椭圆体)   </p>
<ul>
<li>show： 控制雷达体的显示</li>
<li>radii: 雷达体的半径</li>
<li>minimumClock: 雷达体圆周的起始角度</li>
<li>maximumClock：雷达体圆周的最终角度</li>
<li>minimumCone：雷达体内心的最小角度</li>
<li>maximumCone：雷达体内心的最大角度</li>
<li>material：雷达体的材质，目前主要用于控制颜色</li>
<li>outlineColor：雷达体划分线的颜色</li>
<li>SlicePartitions：雷达体划分区域数</li>
</ul>
<p><em><strong>扫描体的实现利用的是Cesium提供的Entity中的Polygon组件，该部分具体实现的核心代码如下所示：</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成雷达的扫描面，主要利用Cesium的polygon接口实现</span><br><span class="line">&#x2F;&#x2F; 要求计算出扫描面顶部各坐标以及底部各坐标</span><br><span class="line">&#x2F;&#x2F; 显示与否、材质颜色都由回调函数动态控制</span><br><span class="line">this.entity &#x3D; new Entity(&#123;</span><br><span class="line">    id: &quot;round_scan&quot; + this._radasid,</span><br><span class="line">    polygon: &#123;</span><br><span class="line">        show: new CallbackProperty(function () &#123; return _this._show &amp;&amp; _this._scanshow; &#125;, false),</span><br><span class="line">        hierarchy: new CallbackProperty(() &#x3D;&gt; &#123;</span><br><span class="line">            let pos &#x3D; Cartesian3.fromDegreesArrayHeights(_this.positionArr);</span><br><span class="line">            return new PolygonHierarchy(pos);</span><br><span class="line">        &#125;, false),</span><br><span class="line">        perPositionHeight: true,</span><br><span class="line">        material: new ColorMaterialProperty(new CallbackProperty(function () &#123;</span><br><span class="line">            return Color.fromCssColorString(_this._scancolor);</span><br><span class="line">        &#125;, false)),</span><br><span class="line">        outline: true,</span><br><span class="line">        outlineColor: Color.BLACK</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 向组件集合中添加扫描体</span><br><span class="line">this.sensorEntities.set(&quot;round_scan&quot; + this._radasid, this.entity);</span><br></pre></td></tr></table></figure>
<p>下面对扫描体各属性作简单的说明：<br>id：扫描体的id，由构造函数输入确定。<br>polygon(多边形)   </p>
<ul>
<li>show： 控制扫描体的显示</li>
<li>hierarchy: 扫描体的边界顶部各点坐标，由calcPoints函数计算得到（之后会做进一步的说明）</li>
<li>perPositionHeight: 对应hierarchy中各边界点的底部边界坐标点的高度集合</li>
<li>material：扫描体的材质，目前主要用于控制颜色</li>
</ul>
<p><em><strong>扫描体的核心函数calcPoints由下所示</strong></em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * @abstract 计算相控阵雷达扫描面各顶点的坐标</span><br><span class="line">     * @param x1 中心点的经度</span><br><span class="line">     * @param y1 中心点的纬度</span><br><span class="line">     * @param height 中心点的高度</span><br><span class="line">     * @param radius 雷达扫描的半径</span><br><span class="line">     * @param heading 雷达扫描经过的角度</span><br><span class="line">     * @returns 返回扫描线在圆周上的一系列坐标点</span><br><span class="line">     * 首先根据heading、pitch、roll在雷达中心点上建立eastNorthUp坐标系</span><br><span class="line">     * 依据heading计算出扫描线与圆周的交点，并依据该点与中心点计算出扫描线</span><br><span class="line">     * 最后利用minimumCone和maximumCone参数对扫描线进行切割，得到最终的扫描线</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public calcPoints(x1: number, y1: number, height: number, radius: number, heading: number) &#123;</span><br><span class="line"></span><br><span class="line">        let positionArr &#x3D; [];</span><br><span class="line">        this.minimumheight &#x3D; [];</span><br><span class="line">        positionArr.push(x1);</span><br><span class="line">        positionArr.push(y1);</span><br><span class="line">        positionArr.push(height);</span><br><span class="line">        this.minimumheight.push(height);</span><br><span class="line"></span><br><span class="line">        let hpr &#x3D; HeadingPitchRoll.fromDegrees(this.hpr.heading, this.hpr.pitch, this.hpr.roll);</span><br><span class="line">        let m &#x3D; Transforms.headingPitchRollToFixedFrame(Cartesian3.fromDegrees(x1, y1, height), hpr, Ellipsoid.WGS84, Transforms.eastNorthUpToFixedFrame);</span><br><span class="line"></span><br><span class="line">        for (let i &#x3D; - 90; i &lt;&#x3D; 90.0; i++) &#123;</span><br><span class="line"></span><br><span class="line">            if (i &lt; this._scanrange[2] - 90 || i &gt; this._scanrange[3] - 90) continue;</span><br><span class="line">            let rx &#x3D; Math.cos(-i * Math.PI &#x2F; 180.0) * radius * Math.cos(heading * Math.PI &#x2F; 180.0);</span><br><span class="line">            let ry &#x3D; Math.cos(-i * Math.PI &#x2F; 180.0) * radius * Math.sin(heading * Math.PI &#x2F; 180.0);</span><br><span class="line">            let rh &#x3D; radius * Math.sin(-i * Math.PI &#x2F; 180.0);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; console.log(rx, ry);</span><br><span class="line"></span><br><span class="line">            let translation &#x3D; Cartesian3.fromElements(rx, ry, rh);</span><br><span class="line"></span><br><span class="line">            let d &#x3D; Matrix4.multiplyByPoint(m, translation, new Cartesian3());</span><br><span class="line">            let c &#x3D; Cartographic.fromCartesian(d);</span><br><span class="line"></span><br><span class="line">            let _translation &#x3D; Cartesian3.fromElements(rx, ry, 0);</span><br><span class="line">            let _d &#x3D; Matrix4.multiplyByPoint(m, translation, new Cartesian3());</span><br><span class="line">            let _c &#x3D; Cartographic.fromCartesian(_d);</span><br><span class="line">            let lgt &#x3D; _Math.toDegrees(c.longitude);</span><br><span class="line">            let lat &#x3D; _Math.toDegrees(c.latitude);</span><br><span class="line">            &#x2F;&#x2F; console.log(lgt + &quot;  &amp;  &quot; + lat);</span><br><span class="line"></span><br><span class="line">            positionArr.push(lgt);</span><br><span class="line">            positionArr.push(lat);</span><br><span class="line">            positionArr.push(c.height);</span><br><span class="line">            this.minimumheight.push(_c.height);</span><br><span class="line">        &#125;</span><br><span class="line">        return positionArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>基本思路:首先根据heading、pitch、roll在雷达中心点上建立eastNorthUp坐标系，依据旋转进程heading计算出扫描线与圆周的交点，并依据该点与中心点计算出扫描线。最后利用minimumCone和maximumCone参数对扫描线进行切割，得到最终的扫描线各点坐标，用于之后再polygon中传入给hierarchy及perPositionHeight参数。</p>
<p>##雷达效果</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public init() &#123;</span><br><span class="line">    let pos &#x3D; Cartesian3.fromDegrees(114, 30, 5000);</span><br><span class="line">    &#x2F;&#x2F; tslint:disable-next-line:variable-name</span><br><span class="line">    let Scanoptions &#x3D; &#123; initial_heading: 0, scantype: 2, scanrange: [60, 300], sacnspeed: this.speed &#125;;</span><br><span class="line">    this.sensor &#x3D; new _Sen(</span><br><span class="line">        this.cmap,</span><br><span class="line">        &#123; radasid: &quot;radas1&quot;, id: &quot;Plane1&quot;, position: pos, size: 2000, show: this.isShow, slicecolor: this.slicecolor, facecolor: &quot;rgba(0, 0, 255, 0.2)&quot;, scancolor: &quot;rgba(255, 0, 0, 0.7)&quot;, type: this.radars.value, detect: false, scanoptions: Scanoptions &#125;</span><br><span class="line">    );</span><br><span class="line">    this.cmap.addLayer(this.sensor);</span><br><span class="line">    this.cmap.viewer?.zoomTo(this.cmap.viewer?.entities);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果:<br><img src="/2021/04/20/Cesium-Radar/Radar.gif" alt="固定点radar"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/15/Leetcode-Daily-7-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/15/Leetcode-Daily-7-15/" class="post-title-link" itemprop="url">Leetcode_Daily_7-15_不同的二叉搜索树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-15 08:57:01" itemprop="dateCreated datePublished" datetime="2020-07-15T08:57:01+08:00">2020-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-20 14:41:16" itemprop="dateModified" datetime="2021-04-20T14:41:16+08:00">2021-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/07/15/Leetcode-Daily-7-15/description.png"></p>
<hr>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>令G(n)表示以n个数为节点组成的二叉搜索树的个数<br>令f(i)表示以数i为根结点的二叉搜索树个数<br>则G(n)=f(1)+f(2)+···+f(n)<br>而f(i)=G(i-1)*G(n-i)<br>故G(n)=G(0)*G(n-1)+G(1)*G(n-2)+···+G(i-1)*G(n-i)+···+G(n-1)*G(0)  </p>
<p>根据上述思路，可以容易地计算得到不同的二叉搜索树个数</p>
<hr>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="/2020/07/15/Leetcode-Daily-7-15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/14/Leetcode-Daily-7-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="XinLai">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/14/Leetcode-Daily-7-13/" class="post-title-link" itemprop="url">Leetcode_Daily_7-13_三角形最小路径和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-14 20:30:16" itemprop="dateCreated datePublished" datetime="2020-07-14T20:30:16+08:00">2020-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-20 14:42:47" itemprop="dateModified" datetime="2021-04-20T14:42:47+08:00">2021-04-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2020/07/14/Leetcode-Daily-7-13/description.jpg"></p>
<hr>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道经典的动态规划的问题，可以采取自下而上与自上而下的两种方法。<br>前者一般采用递归的方式，方程可表示为:<br>f(i,j)=min(f(i+1,j),f(i+1,j+1))+triangle[i][j]<br>f(i,j)表示从最底层到三角形(i,j)处的最短距离<br>f(0,0)就表示三角形最小路径和<br>为了减少迭代次数，通常会用额外的空间记录f(i,j)的值<br>(实际编程时，还是超时了)  </p>
<p>自上而下一般采用迭代的方法即可<br>f(i,j)=min(f(i-1,j-1),f(i-1,j))+triangle[i][j]</p>
<hr>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="/2020/07/14/Leetcode-Daily-7-13/digui.jpg">  </p>
<p><img src="/2020/07/14/Leetcode-Daily-7-13/dp.jpg"></p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XinLai"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">XinLai</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jscksy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jscksy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:m202077343@hust.edu.cn" title="E-Mail → mailto:m202077343@hust.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XinLai</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
